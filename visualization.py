import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from model import SWEEM
import seaborn as sns
import torch

'''
Creates a visual heatmap of the attention weights for the model's performance
on all genes. As an input, takes in a list of attention weights for each gene.

Args:
    gene_attention (list of float): Attention weights for each gene.
'''
def generateHeatmap(gene_attention, name="Pathway Module Genes"):
    fig, (ax_heatmap, ax_line) = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={'height_ratios': [4, 1]})

    # Create a 1D heatmap
    sns.heatmap([gene_attention], cmap="YlGnBu", cbar=False, ax=ax_heatmap)
    ax_heatmap.set_yticks([])  # Remove y-axis ticks
    ax_heatmap.set_title(f"1D Heatmap of {name}")

    # Create a line graph
    ax_line.plot(gene_attention, color='blue')
    ax_line.set_xlabel("Index")
    ax_line.set_ylabel("Amplitude")
    ax_line.set_title(f"Line Graph of {name}")

    # Show the plot
    plt.tight_layout()
    plt.show()


'''
Baseline visualization. Provides a visual heatmap of the pathway modules, which
were similarly used in the DeepOmix. The heatmap is generated by summing the
values of each gene in the pathway module.
'''
def visualizePathwayModules(rna = True, scna = True, methy = True):
    train_data = pd.read_csv("data/train.csv").dropna(axis=0)
    omix_datas = pd.read_csv("data/pathway_module.csv").dropna(axis=0)
    train_data_keys = list(train_data.columns)

    rna_keys = train_data_keys[:5539]
    rna_keys = set([label.split("_")[0] for label in rna_keys])
    scna_keys = train_data_keys[5540:11046]
    scna_keys = set([label.split("_")[0] for label in scna_keys])
    methy_keys = train_data_keys[11047:15892]
    methy_keys = set([label.split("_")[0] for label in methy_keys])

    pathway_datas_keys = set(omix_datas.columns)
    rna_keys = rna_keys if rna else pathway_datas_keys
    scna_keys = scna_keys if scna else pathway_datas_keys
    methy_keys = methy_keys if methy else pathway_datas_keys

    mutual_keys = pathway_datas_keys & rna_keys & scna_keys & methy_keys
    omix_data = omix_datas[list(mutual_keys)].to_numpy()

    '''
    This next part is to get the sum of the omix data for each gene. This
    step could be improved in the future, because as of now, we are combining
    but potetntially confounding the effects of each of these processes.
    '''
    omix_data = np.sum(omix_data, axis=0)

    scaler = MinMaxScaler()
    omix_data = scaler.fit_transform(omix_data.reshape(-1, 1)).flatten()
    print(f"Omix Data Shape: {omix_data.shape}")
    generateHeatmap(omix_data)
    

'''
Integrated gradients visualization. Provides the integrated gradients
for a single forward pass of the model. Used in visualization.ipynb.
'''
def integrated_gradients(model, event, kwarg_dict, baseline=None, num_steps=50):
    event = event.requires_grad_()
    kwarg_dict = {k: v.requires_grad_() for k, v in kwarg_dict.items()}
    input_data = kwarg_dict['methy']
    

    if baseline is None:
        baseline = torch.zeros_like(input_data)

    scaled_inputs = [baseline + (float(i) / num_steps) * (input_data - baseline) for i in range(num_steps + 1)]

    total_gradients = torch.zeros_like(input_data)

    criterion = torch.nn.BCELoss()

    for scaled_input in scaled_inputs:
        scaled_input = scaled_input.requires_grad_()
        # Compute the model outputs
        outputs = model(event=event, rna=kwarg_dict['rna'], scna=kwarg_dict['scna'], methy=scaled_input)
        # Compute the loss between the model outputs and the target
        loss = criterion(outputs, event)

        grads = torch.autograd.grad(loss, (event, kwarg_dict['rna'], kwarg_dict['scna'], scaled_input), allow_unused=True)[0]
        total_gradients += grads.detach()  # Detach to prevent memory leak

    # Calculate integrated gradients after the loop
    integrated_grad = (input_data - baseline) * total_gradients / num_steps
    return integrated_grad


# '''
# Model attention-based visualization. Provides a visual heatmap of how the model
# interactions with each gene. The heatmap is generated by evaluating how much
# each one of the genes contributes to the model's output performance.
# '''
# def visualizeModelAttention():
#     pass

visualizePathwayModules(rna=False, scna=False, methy=True)